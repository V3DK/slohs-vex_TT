/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
#include "vex.h"
#include <cmath>
using namespace vex;
competition Competition;

/*  broken ports
PORT 5 - works, but randomly spins
PORT 4 - dead
PORT 3 - dead
*/

// VEXcode device constructors
motor frontLeft = motor(PORT11, gearSetting::ratio18_1); 
motor backLeft = motor(PORT7, gearSetting::ratio18_1); 
motor frontRight = motor(PORT17, gearSetting::ratio18_1, true);
motor backRight = motor(PORT6, gearSetting::ratio18_1, true);

motor leftRoller = motor(PORT1, gearSetting::ratio18_1);
motor rightRoller = motor(PORT2, gearSetting::ratio18_1);
motor angler = motor(PORT19, gearSetting::ratio36_1, true);
motor lift = motor(PORT18, gearSetting::ratio36_1, false);

controller Controller1 = controller();

timer autoTimer = timer();

/*    VARIABLES    */

  //auto selection
  int autoPos = 1;
  const int autoMax = 6;

  //mathematical constants
  const int maxSpeed = 100;
  const float math_Pi = 3.1415926535897932384626433;

  //autonomous variables
  bool redSide = true;
  bool autoRunning = false;

  //drive booleans
  bool driveLockOn = false;
  bool straightMove = false;
  double driveFrac = 1;

  //lift variables (preset control)
  bool liftEnabled = false;
  int liftPos = 0;
  int prevLiftPos = 0;

  //roller speed control
  double rollerFrac = 1;

  //angler rotation and states
  int aPos;

  /* PID + SLEW RATE */
  bool pidRunning = false;
    bool initPidStop = false;
  bool turnRunning = false;

  float pidReqValue = 0; 
  float tReq = 0;

  //speeds
  int pidSpeed = 0;
  int tSpeed = 0;

  bool pidSlew = false;
  bool turnSlew = false;

  //drive constants
  float kp = 0.28;
  float ki = 0.0;
  float kd = 0.0;
  //0.3

  //turn constants
  float tKp = 0.3;
  float tKd = 0;
  
float leftAvg(){
    //avg the 2 values
    return ((frontLeft.rotation(rotationUnits::deg) + 
            backLeft.rotation(rotationUnits::deg)) / 2);
}

//return the avg value of left encoders
float rightAvg(){
    //avg the 2 values
    return ((frontRight.rotation(rotationUnits::deg) + 
            backRight.rotation(rotationUnits::deg)) / 2);
}

float backLeftAvg(){
    //avg the 2 values
    return backLeft.rotation(rotationUnits::deg);
}

float backRightAvg(){
    //avg the 2 values
    return backRight.rotation(rotationUnits::deg);
}

void moveRight(int rVel){
    frontRight.spin(directionType::fwd, rVel, velocityUnits::pct);
    backRight.spin(directionType::fwd, rVel, velocityUnits::pct);
}

void moveLeft(int lVel){
    frontLeft.spin(directionType::fwd, lVel, velocityUnits::pct);
    backLeft.spin(directionType::fwd, lVel, velocityUnits::pct);
}

void resetDrive(){
    moveLeft(0);
    moveRight(0);
    frontLeft.resetRotation();
    backLeft.resetRotation();
    frontRight.resetRotation();
    backRight.resetRotation();
}

void resetOthers(){
    lift.resetRotation();
    rightRoller.resetRotation();
    leftRoller.resetRotation();
    angler.resetRotation();
}


void driveCoast(){
      frontLeft.stop(brakeType::coast);
      backLeft.stop(brakeType::coast);
      backRight.stop(brakeType::coast);
      frontRight.stop(brakeType::coast);
    }

/*---------------------------------------------------------------------------------------------------------------*/

//isDriving
int count = 0;
float last = 0;

//everything in absolute value
bool isDriving(float tar){
  Brain.Screen.clearScreen();

  int lPos = leftAvg();
  int rPos = rightAvg();

  //always positive
  float curr = (abs(lPos) + abs(rPos)) / 2;
  int thresh = 3;
  int target = std::abs(tar);
  /*
  Brain.Screen.printAt(1, 10, "%d", target);
  Brain.Screen.printAt(1, 30, "%d", count);
  Brain.Screen.printAt(1, 70, "%0.4f", curr);
  Brain.Screen.printAt(1, 90, "%0.4f", last);
  Brain.Screen.printAt(1, 130, "%0.4f", abs(last - curr));
  */
  if((std::abs(last - curr) < thresh) && ((target * 0.7) < curr))
    count++;
  else
    count = 0;

  last = curr;

  //not driving if haven't moved
  if(count > 4){
    return false;
    count = 0;
    last = 0;
  }
  else
    return true;
}

/*---------------------------------------------------------------------------------------------------------------*/

//slew rate
int accel_step = 6;
int deccel_step = 256; //no decel slew (immediate)
int lSpeed = 0;
int rSpeed = 0;

void leftSlew(int leftTarget){
  int step;

  if(abs(lSpeed) < abs(leftTarget))
    step = accel_step;
  else
    step = deccel_step;

  if(leftTarget > lSpeed + step)
    lSpeed += step;
  else if(leftTarget < lSpeed - step)
    lSpeed -= step;
  else
    lSpeed = leftTarget;

  moveLeft(lSpeed);
}

//slew control
void rightSlew(int rightTarget){
  int step;

  if(abs(rSpeed) < abs(rightTarget))
    step = accel_step;
  else
    step = deccel_step;

  if(rightTarget > rSpeed + step)
    rSpeed += step;
  else if(rightTarget < rSpeed - step)
    rSpeed -= step;
  else
    rSpeed = rightTarget;

  moveRight(rSpeed);
}
/*---------------------------------------------------------------------------------------------------------------*/


//stop the pid part from running and reset values passed
//works for normal and turning PID
 void stopPid(){

  initPidStop = true;
    //redundant safeties
   // pidReqValue = 0;
   // pidSpeed = 0;
   // pidDrive = 0;

  /*  moveLeft(0);
    moveRight(0);

    driveCoast();
    */
    resetDrive();
    //tReq = 0;
    //tSpeed = 0;
 }

 void stopTurn(){
    turnRunning = false;

    tReq = 0;
    tSpeed = 0;
    //tDrive = 0;

    moveLeft(0);
    moveRight(0);
    driveCoast();
    resetDrive();

 }


 void startPid(float pReq, int pSpeed, bool pidS, bool blocking){ //pReq in inches
    resetDrive();

    pidReqValue = (pReq / (4 * math_Pi)) * 360;
    pidSpeed = pSpeed;
    pidSlew = pidS;
    pidRunning = true;

    if(blocking) {
      //wait until pidRunning is false
      while(pidRunning){
        task::sleep(15);
      } 
    }
    
    //Brain.Screen.printAt(1, 115, "Done!");
 }

//positive tReq = right turn!
 void startTurn(float tReqVal, int turnSpeed, bool turnS, bool blocking){
    resetDrive();
    tReq = (tReqVal / (4 * math_Pi)) * 360;    
    tSpeed = turnSpeed;
    turnSlew = turnS;
    turnRunning = true;
    
    if(blocking) {
      //wait until turnRunning is false
      while(turnRunning){
        task::sleep(15);
      } 
    }
 }

 void finishPidDrive(){
  while(pidRunning){
      task::sleep(15);
    } 
 }

 void finishPidTurn(){
  while(turnRunning){
        task::sleep(15);
    }
 }


/*---------------------------------------------------------------------------------------------------------------*/


int pidTask(){
    //normal
    float  pidCurrValue;
    int    pidError;
    float  pidLastError;
    float  pidDerivative;
    //float  pidIntegral;
    int    pidDrive;

    //clearEncoders
    resetDrive();

    pidLastError = 0;
     while(true){

        if(pidRunning){
            //Brain.Screen.clearScreen();

            //read sensor value from Avg func
            pidCurrValue = (rightAvg() + leftAvg()) / 2;
            pidError = pidReqValue - pidCurrValue;
/*
            if(abs(pidError) < 50) 
                    //pidIntegral = pidIntegral + pidError;
                else
                    pidIntegral = 0;
                    */

            pidDerivative = pidError - pidLastError;

            pidLastError = pidError;

            pidDrive = (kp * pidError) + (kd * pidDerivative);
            //limit drive - speed based on pidSpeed variable passed in
            if(pidDrive > pidSpeed)
                pidDrive = pidSpeed;
            else if(pidDrive < (-pidSpeed))
                pidDrive = (-pidSpeed);

            //stopping state - if drive power super small, (less than 3) and error is equal to last error, robot is stopped
            if(!isDriving(pidReqValue)){
                stopPid();
            }    


            if (initPidStop) {
              pidRunning = false;
              pidDrive = 0;
            }

            //send to drive motors - values already scaled to speed
            if(pidSlew){
              rightSlew(pidDrive);
              leftSlew(pidDrive);
            }
            else {
              moveLeft(pidDrive);
              moveRight(pidDrive);
            }   

        }
        //pid not running
        else {
          if (initPidStop) {
              moveRight(0);
              moveLeft(0);
              driveCoast();
              initPidStop = false;
          }
            // clear all
            pidError       = 0;
            pidLastError   = 0;
            pidDerivative  = 0;
            pidReqValue    = 0;
            pidSpeed       = 0;

        }

            //to not waste resources
            task::sleep(25);
        }
        return 0;
}


int turnTask(){
    //turning
    float  tCurr = 0;
    int    tError = 0;
    float  tLastError = 0;
    float  tDeriv = 0;
    int    tDrive = 0;


    //clearEncoders
    resetDrive();

     while(true){
        //turning pid
        if(turnRunning){
            //guarentees correct sign - right turn is pos, left is neg
            tCurr = (backLeftAvg() - backRightAvg()) / 2;
            //tCurr = leftAvg();
            tError = tReq - tCurr;

            tDeriv = tError - tLastError;
            tLastError = tError;

            tDrive = (tKp * tError) + (tKd * tDeriv);
            //limit drive - speed based on pidSpeed variable passed in
            if(tDrive > tSpeed)
                tDrive = tSpeed;
            else if(tDrive < (-tSpeed))
                tDrive = (-tSpeed);

            //stoppping state - if drive power super small, (less than 3) and error is equal to last error, robot is stopped
            if(!isDriving(tReq)){
              tDrive = 0;
                stopTurn();
            }        

            if(turnSlew){
              leftSlew(tDrive);
              rightSlew(-tDrive);
            }
            else {
              moveLeft(tDrive);
              moveRight(-tDrive);
            }   


        }
        else {
            tError = 0;
            tLastError = 0;
            tDeriv = 0;
            tReq = 0;
            tSpeed = 0;
        }
            //to not waste resources
            task::sleep(25);
        }
        return 0;
}



/*---------------------------------------------------------------------------------------------------------------*/


void pre_auton(void) {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();

    //reset drive encoders
    resetDrive();
    //reset all other encoders
    resetOthers();
    Brain.Screen.clearScreen();
    Brain.Screen.printAt(1, 15, "Ready!");
}

    void driveHold(){
      frontLeft.stop(brakeType::hold);
      backLeft.stop(brakeType::hold);
      backRight.stop(brakeType::hold);
      frontRight.stop(brakeType::hold);
    }
    
    //function to toggle lock and coast with boolean
    void driveLock(bool z){
        // if z is true, lock is turned on
        // else, it's turned off
        if(z){
            driveHold(); 
        }
        else if(!z) {
            driveCoast();
        }
    }

    //timeout drive for time
    void driveTimeout(float leftTime, float rightTime){
        frontLeft.setTimeout(leftTime, timeUnits::msec);
        backLeft.setTimeout(leftTime, timeUnits::msec);
        frontRight.setTimeout(rightTime, timeUnits::msec);
        backRight.setTimeout(rightTime, timeUnits::msec);
    }

    void liftTimeout(int time){
      lift.setTimeout(time, timeUnits::msec);
    }
    void anglerTimeout(int time){
      angler.setTimeout(time, timeUnits::msec);
    }

float startTime, endTime;

void blue8(){
  startTime = autoTimer.system();
  autoTimer.clear();
  //clear screen
  Brain.Screen.clearScreen();

  //set holds for auto movement
  angler.setStopping(brakeType::hold);
  leftRoller.setStopping(brakeType::hold);
  rightRoller.setStopping(brakeType::hold);
  lift.setStopping(brakeType::hold);

  //reset encoders
  resetOthers();
  resetDrive();

  //drive through first row
  //startPid(10, 20, true, false);

  //outtake rollers to flip them
  leftRoller.rotateFor(-540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, true);

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //finishPidDrive();

  //drive through first row
  startPid(31.5, 40, true, true);

  //turn 
  //startTurn(3.95, 100, false, true);
  startTurn(4.1, 100, false, true);

  //stop rollers
  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  //drive hypotenuse
  startPid(-32, 100, true, true);

  //second little turn
  startTurn(-4.1, 100, false, true); 

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //drive through second row
  startPid(35, 38, true, true);


  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  task::sleep(50);
  //drive back
  startPid(-23, 100, true, false);

  while (std::abs((rightAvg() + leftAvg()) / 2) < 140) {
    task::sleep(20);
  }

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);

  //start angling
  angler.rotateTo(290, vex::rotationUnits::deg, 75, vex::velocityUnits::pct, false);

  finishPidDrive();

  //turn off roller
  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  //turn towards scoring zone
  startTurn(-13.1, 40, true, true);
  
  //drive into zone
  startPid(15.5, 40, true, true);

  leftRoller.stop(brakeType::coast);
  rightRoller.stop(brakeType::coast);

  driveLock(true);

  aPos = angler.rotation(rotationUnits::deg);
  float tempFrac = 1;

  while(aPos < 810){
    aPos = angler.rotation(rotationUnits::deg);
    float slope = (0.3 - 1) / (810 - 290);
    tempFrac = (slope * aPos) + (1 - (slope * 290));
    angler.spin(directionType::fwd, (maxSpeed * tempFrac), velocityUnits::pct);
  }

  angler.spin(directionType::fwd, (0), velocityUnits::pct);
  //angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  driveLock(false);

  //drive out
  startPid(-10, 75, true, true);

  endTime = autoTimer.system() - startTime;
  Brain.Screen.printAt(1, 80, "%f", (endTime / 1000.0));
}

void red8(){
  startTime = autoTimer.system();
  autoTimer.clear();
  //clear screen
  Brain.Screen.clearScreen();

  //set holds for auto movement
  angler.setStopping(brakeType::hold);
  leftRoller.setStopping(brakeType::hold);
  rightRoller.setStopping(brakeType::hold);
  lift.setStopping(brakeType::hold);

  //reset encoders
  resetOthers();
  resetDrive();

  //drive through first row
  //startPid(10, 20, true, false);

  //outtake rollers to flip them
  leftRoller.rotateFor(-540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, true);

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //finishPidDrive();

  //drive through first row
  startPid(32, 40, true, true);

  //turn 
  //startTurn(3.95, 100, false, true);
  startTurn(-4.1, 100, false, true);

  //stop rollers
  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  //drive hypotenuse
  startPid(-32.5, 100, true, true);

  //second little turn
  startTurn(4.2, 100, false, true); 

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //drive through second row
  startPid(35, 38, true, true);


  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  task::sleep(50);
  //drive back
  startPid(-22, 100, true, false);

  while (std::abs((rightAvg() + leftAvg()) / 2) < 140) {
    task::sleep(20);
  }

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);

  //start angling
  angler.rotateTo(290, vex::rotationUnits::deg, 75, vex::velocityUnits::pct, false);

  finishPidDrive();

  //turn off roller
  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  //turn towards scoring zone
  startTurn(12.7, 40, true, true);
  
  //drive into zone
  startPid(15.5, 40, true, true);

  leftRoller.stop(brakeType::coast);
  rightRoller.stop(brakeType::coast);

  driveLock(true);

  aPos = angler.rotation(rotationUnits::deg);
  float tempFrac = 1;

  while(aPos < 810){
    aPos = angler.rotation(rotationUnits::deg);
    float slope = (0.3 - 1) / (810 - 290);
    tempFrac = (slope * aPos) + (1 - (slope * 290));
    angler.spin(directionType::fwd, (maxSpeed * tempFrac), velocityUnits::pct);
  }

  angler.spin(directionType::fwd, (0), velocityUnits::pct);
  //angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  driveLock(false);

  //drive out
  startPid(-10, 75, true, true);

  endTime = autoTimer.system() - startTime;
  Brain.Screen.printAt(1, 80, "%f", (endTime / 1000.0));
}

void red5(){
  startTime = autoTimer.system();
  autoTimer.clear();
  //clear screen
  Brain.Screen.clearScreen();

  //set holds for auto movement
  angler.setStopping(brakeType::hold);
  leftRoller.setStopping(brakeType::hold);
  rightRoller.setStopping(brakeType::hold);
  lift.setStopping(brakeType::hold);

  //reset encoders
  resetOthers();
  resetDrive();

  //outtake rollers to flip them
  leftRoller.rotateFor(-540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, true);

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);


  //drive through first row
  startPid(40, 30, true, true);

  task::sleep(150);

  //drive back
  startPid(-18, 30, true, false);

  while (std::abs((rightAvg() + leftAvg()) / 2) < 140) {
    task::sleep(20);
  }

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);

  //start angling
  angler.rotateTo(290, vex::rotationUnits::deg, 75, vex::velocityUnits::pct, false);

  finishPidDrive();

  //turn towards scoring zone
  startTurn(12.4, 30, true, true);
  
  //drive into zone
  startPid(16.5, 60, true, true);

  leftRoller.stop(brakeType::coast);
  rightRoller.stop(brakeType::coast);

  driveLock(true);

  aPos = angler.rotation(rotationUnits::deg);
  float tempFrac = 1;

  while(aPos < 840){
    aPos = angler.rotation(rotationUnits::deg);
    float slope = (0.2 - 1) / (840 - 290);
    tempFrac = (slope * aPos) + (1 - (slope * 290));
    angler.spin(directionType::fwd, (maxSpeed * tempFrac), velocityUnits::pct);
  }

  angler.spin(directionType::fwd, (0), velocityUnits::pct);
  //angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  driveLock(false);

  //drive out
  startPid(-5, 30, true, true);
  angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  startPid(-5, 30, true, true);


  endTime = autoTimer.system() - startTime;
  Brain.Screen.printAt(1, 80, "%f", (endTime / 1000.0));
}

void blue5(){
  startTime = autoTimer.system();
  autoTimer.clear();
  //clear screen
  Brain.Screen.clearScreen();

  //set holds for auto movement
  angler.setStopping(brakeType::hold);
  leftRoller.setStopping(brakeType::hold);
  rightRoller.setStopping(brakeType::hold);
  lift.setStopping(brakeType::hold);

  //reset encoders
  resetOthers();
  resetDrive();

  //outtake rollers to flip them
  leftRoller.rotateFor(-540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, true);

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);


  //drive through first row
  startPid(40, 30, true, true);

  task::sleep(150);

  //drive back
  startPid(-18, 30, true, false);

  while (std::abs((rightAvg() + leftAvg()) / 2) < 140) {
    task::sleep(20);
  }

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);

  //start angling
  angler.rotateTo(290, vex::rotationUnits::deg, 75, vex::velocityUnits::pct, false);

  finishPidDrive();

  //turn towards scoring zone
  startTurn(-13.5, 30, true, true);
  
  //drive into zone
  startPid(18, 30, true, true);

  leftRoller.stop(brakeType::coast);
  rightRoller.stop(brakeType::coast);

  driveLock(true);

  aPos = angler.rotation(rotationUnits::deg);
  float tempFrac = 1;

  while(aPos < 840){
    aPos = angler.rotation(rotationUnits::deg);
    float slope = (0.2 - 1) / (840 - 290);
    tempFrac = (slope * aPos) + (1 - (slope * 290));
    angler.spin(directionType::fwd, (maxSpeed * tempFrac), velocityUnits::pct);
  }

  angler.spin(directionType::fwd, (0), velocityUnits::pct);
  //angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  driveLock(false);

  //drive out
  startPid(-5, 30, true, true);
  angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  startPid(-5, 30, true, true);


  endTime = autoTimer.system() - startTime;
  Brain.Screen.printAt(1, 80, "%f", (endTime / 1000.0));
}

void bigBlue5(){
  startTime = autoTimer.system();
  autoTimer.clear();
  //clear screen
  Brain.Screen.clearScreen();

  //set holds for auto movement
  angler.setStopping(brakeType::hold);
  leftRoller.setStopping(brakeType::hold);
  rightRoller.setStopping(brakeType::hold);
  lift.setStopping(brakeType::hold);

  //reset encoders
  resetOthers();
  resetDrive();

  //outtake rollers to flip them
  leftRoller.rotateFor(-540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, true);

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //drive through first cube
  startPid(10, 60, true, true);

  //little turn to tower cube
  startTurn(-1.5, 40, true, true); 

/*
  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);
  */


  //drive to second cube
  startPid(36.5, 80, true, true);

  task::sleep(200);

  //drive back
  startPid(-24, 80, true, false);

  while (std::abs((rightAvg() + leftAvg()) / 2) < 150) {
    task::sleep(20);
  }

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);

  finishPidDrive();

  //turn to face others
  startTurn(-6.85, 30, true, true); 

  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //drive to third cube
  startPid(25, 35, true, true);

  task::sleep(200);

  //drive home 
  startPid(-25, 75, true, true);

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::coast);
  rightRoller.stop(brakeType::coast);

  //turn to scoring zone
  startTurn(-14.1, 40, true, true); 
  
  //drive into zone
  startPid(9, 80, true, true);

  angler.rotateTo(290, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  aPos = angler.rotation(rotationUnits::deg);
  float tempFrac = 1;

  while(aPos < 840){
    aPos = angler.rotation(rotationUnits::deg);
    float slope = (0.5 - 1) / (840 - 290);
    tempFrac = (slope * aPos) + (1 - (slope * 290));
    angler.spin(directionType::fwd, (maxSpeed * tempFrac), velocityUnits::pct);
  }

  angler.spin(directionType::fwd, (0), velocityUnits::pct);
  //angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  //drive out
  startPid(-10, 30, true, true);
  angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  endTime = autoTimer.system() - startTime;
  Brain.Screen.printAt(1, 80, "%f", (endTime / 1000.0));
}

void bigRed5(){
	startTime = autoTimer.system();
  autoTimer.clear();
  //clear screen
  Brain.Screen.clearScreen();

  //set holds for auto movement
  angler.setStopping(brakeType::hold);
  leftRoller.setStopping(brakeType::hold);
  rightRoller.setStopping(brakeType::hold);
  lift.setStopping(brakeType::hold);

  //reset encoders
  resetOthers();
  resetDrive();

  //outtake rollers to flip them
  leftRoller.rotateFor(-540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(540, vex::rotationUnits::deg, maxSpeed, vex::velocityUnits::pct, true);

  //turn on roller to start intaking
  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //drive through first cube
  startPid(10, 60, true, true);

  //little turn to tower cube
  startTurn(1.65, 40, true, true); 

  //drive to second cube
  startPid(37, 80, true, true);

  task::sleep(200);

  //drive back
  startPid(-24, 80, true, false);

  while (std::abs((rightAvg() + leftAvg()) / 2) < 150) {
    task::sleep(20);
  }

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::hold);
  rightRoller.stop(brakeType::hold);

  finishPidDrive();

  //turn to face others
  startTurn(7.2, 30, true, true); 

  leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);

  //drive to third cube
  startPid(25, 35, true, true);

  task::sleep(200);

  //drive home 
  startPid(-25, 75, true, true);

  leftRoller.spin(directionType::fwd, (0), velocityUnits::pct);
  rightRoller.spin(directionType::rev, (0), velocityUnits::pct);

  leftRoller.stop(brakeType::coast);
  rightRoller.stop(brakeType::coast);

  //turn to scoring zone
  startTurn(14.1, 40, true, true); 
  
  //drive into zone
  startPid(9, 80, true, true);

  angler.rotateTo(290, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  aPos = angler.rotation(rotationUnits::deg);
  float tempFrac = 1;

  while(aPos < 840){
    aPos = angler.rotation(rotationUnits::deg);
    float slope = (0.5 - 1) / (840 - 290);
    tempFrac = (slope * aPos) + (1 - (slope * 290));
    angler.spin(directionType::fwd, (maxSpeed * tempFrac), velocityUnits::pct);
  }

  angler.spin(directionType::fwd, (0), velocityUnits::pct);
  //angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  //drive out
  startPid(-10, 30, true, true);
  angler.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

  endTime = autoTimer.system() - startTime;
  Brain.Screen.printAt(1, 80, "%f", (endTime / 1000.0));
}

void tuningPid(){
  tKp = 0.3;
  tKd = 0.0;
  kp = 0.28;

  Brain.Screen.clearScreen();
  resetDrive();
  driveCoast();

  //turn towards scoring zone
  //startTurn(13.3, 40, true, true);
  
  //drive into zone
  startPid(-33, 100, true, true);

  startTurn(3.4, 100, true, true);

  leftRoller.rotateFor(20, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  rightRoller.rotateFor(-20, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
}


void autonomous(void) {
  task pidTasks(pidTask);
  task turnTasks(turnTask);
  autoRunning = true;

  resetDrive();
  resetOthers();
if(autoPos == 1)
  	red8();
else if(autoPos == 2)
  	blue8();
else if(autoPos == 3)
  	red5();
else if(autoPos == 4)
  	blue5();
else if(autoPos == 5)
  	bigRed5();
else if(autoPos == 6)
  	bigBlue5();

  //stop pid task - only needed for auto
  task::stop(pidTask); 
  task::stop(turnTask); 

  autoRunning = false;

  //wait 10 seconds - just in case (no repeat)
  task::sleep(10000);
}

void driveLockDetect(){
        if(Controller1.ButtonLeft.pressing()){
           //wait until released
           while(Controller1.ButtonLeft.pressing()){
               task::sleep(100);
           }
           //run func
            driveLockOn = !driveLockOn;
           driveLock(driveLockOn);
       }
    }

    void straightDrive(){
      if(Controller1.ButtonUp.pressing()){
        straightMove = true;
        while(Controller1.ButtonUp.pressing()){
          //moveLeft(40);
          //moveRight(40);
          leftSlew(70);
          rightSlew(70);
        }
      }
      else if(Controller1.ButtonDown.pressing()){
        straightMove = true;
        while(Controller1.ButtonDown.pressing()){
          if(aPos > 600){
           leftSlew(-20);
           rightSlew(-20);
          }
          else {
          leftSlew(-40);
          rightSlew(-40);
        }
        }
      }
      straightMove = false;
    }

int liftDeg = 0;
bool rollersOn = false; 

void liftButtonDetect(){
  
  liftDeg = lift.rotation(rotationUnits::deg);

  //increment and decrement buttons
  if(Controller1.ButtonX.pressing()){
           //wait until released
           while(Controller1.ButtonX.pressing()){
               task::sleep(25);
           }

           prevLiftPos = liftPos;

           if((liftPos == 0) || (liftPos == 1)){
            liftPos = 2;
           }
           else {
            liftPos = 1;
           }
            
            liftEnabled = true;

           }
       else if(Controller1.ButtonB.pressing()){
        //wait until released
           while(Controller1.ButtonB.pressing()){
               task::sleep(25);
           }

           prevLiftPos = liftPos;

           if((liftPos == 1) || (liftPos == 2)){
            liftPos = 0;
           }
           else {
            liftPos = 1;
           }
            
            liftEnabled = true;
           }

       if(Controller1.ButtonA.pressing()){
          lift.spin(directionType::fwd, (maxSpeed * 0.75), velocityUnits::pct);
        }
        else if(Controller1.ButtonY.pressing()){
          lift.spin(directionType::rev, (maxSpeed * 0.75), velocityUnits::pct);
        }
        else if(!liftEnabled){
          if(liftDeg > 75) {
            lift.stop(brakeType::hold);
          }
          else {
            //if(rollersOn)
             // lift.spin(directionType::rev, (0), velocityUnits::pct);
            //else
              lift.stop(brakeType::coast);
          }
        }  
}

void liftMovement(){
  if(liftEnabled){

    if(liftPos == 0){      
      anglerTimeout(1000);
      angler.rotateTo(0, rotationUnits::deg, 100, velocityUnits::pct, false);

      lift.stop(brakeType::coast);
      liftTimeout(1000);
      lift.rotateTo(0, rotationUnits::deg, 100, velocityUnits::pct, true);
    }

    else if(liftPos == 1){

      if(prevLiftPos == 0){
        leftRoller.rotateFor(-200, rotationUnits::deg, 100, velocityUnits::pct, false);
        rightRoller.rotateFor(200, rotationUnits::deg, 100, velocityUnits::pct, false);
      }

      liftTimeout(1000);
      if(prevLiftPos == 2)
      	lift.rotateTo(355, rotationUnits::deg, 50, velocityUnits::pct, true); 
      else if(prevLiftPos == 0)
      	lift.rotateTo(355, rotationUnits::deg, 100, velocityUnits::pct, true); 

      lift.stop(brakeType::hold);
    }

    else if(liftPos == 2){

      if(prevLiftPos == 0){
        leftRoller.rotateFor(-200, rotationUnits::deg, 100, velocityUnits::pct, false);
        rightRoller.rotateFor(200, rotationUnits::deg, 100, velocityUnits::pct, false);
      }

      
      liftTimeout(1000);
      if(prevLiftPos == 1)
      	lift.rotateTo(470, rotationUnits::deg, 50, velocityUnits::pct, true); 
      else if(prevLiftPos == 0)
      	lift.rotateTo(470, rotationUnits::deg, 100, velocityUnits::pct, true); 
      lift.stop(brakeType::hold);
    }

  }
  //turn off lift movement
  liftEnabled = false;
}

int liftDetection(){
  while(true){
    if(!autoRunning){
      liftButtonDetect();
    }
    task::sleep(20);
  }
return 0;
}

int liftRotation(){
  while(true){
    if(!autoRunning){
      liftMovement();
    }
    task::sleep(20);
  }
return 0;
}

int driveTask(){
  while(true){
    if(!autoRunning){
      driveLockDetect();
      straightDrive();
    }
    task::sleep(20);
  }
  return 0;
    }

    void controllerDisplay(){
      Controller1.Screen.clearScreen();
        if(!driveLockOn){
          Controller1.Screen.setCursor(3, 1);
          Controller1.Screen.print("Off");
        }
        else
        {
          Controller1.Screen.setCursor(3, 1);
          Controller1.Screen.print("On");
        }    
    }

    void brainDisplay(){
        Brain.Screen.clearScreen();

        Brain.Screen.printAt(1, 20, "auto:");

        if(autoPos == 1)
		  	Brain.Screen.printAt(100, 20, "unprot red 8 cube");
		else if(autoPos == 2)
		  	Brain.Screen.printAt(100, 20, "unprot blue 8 cube");
		else if(autoPos == 3)
		  	Brain.Screen.printAt(100, 20, "unprot red 5 cube");
		else if(autoPos == 4)
		  	Brain.Screen.printAt(100, 20, "unprot blue 5 cube");
		else if(autoPos == 5)
		  	Brain.Screen.printAt(100, 20, "prot red 4 cube");
		else if(autoPos == 6)
		  	Brain.Screen.printAt(100, 20, "prot blue 4 cube");


        Brain.Screen.printAt(1, 40, "aPos:");
        Brain.Screen.printAt(100, 40, "%d", aPos);

        Brain.Screen.printAt(1, 60, "autoTime:");
        Brain.Screen.printAt(100, 60, "%f", (endTime / 1000));
    }

    //task only used to update brain and controller displays
    //also used to select auton's
    int displayTask(){
      while(true){
        if(!autoRunning){
          controllerDisplay();
          brainDisplay();
        }
          //to not waste resources - 150 cause display doesn't need to be updated super fast
          task::sleep(150);
      }
      return 0;
    }

    void driveTrainControl(void){

    	if(liftPos != 0)
    		driveFrac = 0.75;
    	else
    		driveFrac = 1;

      if(!straightMove){
        //moveLeft(Controller1.Axis3.value() * driveFrac);
        //moveRight(Controller1.Axis2.value() * driveFrac);
        leftSlew((Controller1.Axis3.value() * driveFrac));
        rightSlew(Controller1.Axis2.value() * driveFrac);
      }
/*
      if(aPos > 450)
        driveFrac = 0.40;
      else
        driveFrac = 1;
 */
      
    }

    void rollerControl(void){

    	liftDeg = lift.rotation(rotationUnits::deg);


      if(!liftEnabled){

          if(Controller1.ButtonL2.pressing()){
            rollersOn = true;
            leftRoller.spin(directionType::fwd, (maxSpeed), velocityUnits::pct);
            rightRoller.spin(directionType::rev, (maxSpeed), velocityUnits::pct);
          }
          else if(Controller1.ButtonL1.pressing()){
            rollersOn = true;
            leftRoller.spin(directionType::rev, (maxSpeed * rollerFrac), velocityUnits::pct);
            rightRoller.spin(directionType::fwd, (maxSpeed * rollerFrac), velocityUnits::pct);
          }
          else {

           rollersOn = false;

          if((aPos > 250) || liftPos != 0){
            leftRoller.stop(brakeType::coast);
            rightRoller.stop(brakeType::coast);
          }
          else if((aPos < 250) && (liftPos == 0) && (liftDeg < 100)){
          	leftRoller.spin(directionType::fwd, (maxSpeed * 0.05), velocityUnits::pct);
            rightRoller.spin(directionType::rev, (maxSpeed * 0.05), velocityUnits::pct);
            //leftRoller.stop(brakeType::brake);
            //rightRoller.stop(brakeType::brake);
          }
          }
      }

        if(aPos > 250) {
          rollerFrac = 0.25;
        }
        else {

          if(liftPos == 1){
            rollerFrac = 0.75;
          }
          else if(liftPos == 2){
            rollerFrac = 1;
          }
          else {
            rollerFrac = 1;
          }

    }

  }
    
    double anglerFrac;
    const int aLimit = 10;
    float slope = 0;

    void anglerControl(){ 
      aPos = angler.rotation(rotationUnits::deg);

      if(aPos < aLimit)
        anglerFrac = 1;
      else if(aPos > aLimit) {
        slope = (0.1 - 1) / (810 - aLimit);
        anglerFrac = (slope * aPos) + (1 - (slope * aLimit)); 
      }

    if(!liftEnabled){
        if(Controller1.ButtonR1.pressing() && (aPos < 850)){
          angler.spin(directionType::fwd, (maxSpeed * anglerFrac), velocityUnits::pct);
        }
        else if(Controller1.ButtonR2.pressing() && (aPos > 0)){
          angler.spin(directionType::rev, (maxSpeed), velocityUnits::pct);
        }
        else {
          if(aPos > (75))
            angler.stop(brakeType::hold);
          else
            angler.stop(brakeType::coast);
        }

  }


    }

    void autoSelector(){

    	if(Controller1.ButtonRight.pressing()){
           //wait until released
           while(Controller1.ButtonRight.pressing()){
               task::sleep(20);
           }

           if(autoPos == autoMax)
           	autoPos = 1;
           else
           	autoPos++;
        }
    }
          
    void allRemoteFunc(void){
      if(!autoRunning){
        anglerControl(); 
        rollerControl();
        driveTrainControl();
        autoSelector();
      }
    }

void usercontrol(void) {
  //turn off auto (just in case)
  autoRunning = false;

  //initiate task for triggers, like drive control 
  task driveTriggers(driveTask);
  
  //initiate task for brain and controller displays
  task display(displayTask);

  //initiate lift task
  task liftDetect(liftDetection);
  task liftRot(liftRotation);
  resetDrive();

  //stop auto tasks (just in case auto doesn't complete)
  task::stop(pidTask); 
  task::stop(turnTask);

  while (true) {
    allRemoteFunc();
    wait(20, msec); // Sleep the task for a short amount of time to
  }
}

int main() {
  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);
  // Run the pre-autonomous function.
  pre_auton();
  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
}
